一、单一职责原则
实现高内聚、低耦合的指导方针，需要设计人员发现类的不同职责并将其分离
当变化发生，只影响其中一个职责，那就需要拆分，如果变化都影响到这两个职责，那就不需要拆分。
提高类的可读性，提高系统的可维护性，代码是给人看的


二.开闭原则(Open-Closed Principle, OCP)
软件实体应尽量在不修改原有代码的情况下进行扩展：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现使我们需要的
开闭原则可以提高复用性、开闭原则可以提高维护性


三、里氏代换原则(Liskov Substitution Principle, LSP)
所有引用基类（父类）的地方必须能透明地使用其子类的对象
代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；提高代码的重用性；子类可以形似父类，但又异于父类；提高代码的可扩展性，实现父类的方法就可以“为所欲为”了;提高产品或项目的开放性。
继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；降低代码的灵活性。子类必须拥有父类的属性和方法；


四、依赖倒置原则（Dependence Inversion Principle，DIP）
高层模块不应该依赖低层模块，两者都应该依赖其抽象；要面向接口编程，不要面向实现编程。


五、接口隔离原则(Interface Segregation Principle, ISP)
使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口
接口隔离原则是为了约束接口、降低类对接口的依赖性
可以预防外来变更的扩散，提高系统的灵活性和可维护性。
如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低
能减少项目工程中的代码冗余。


六、迪米特法则(Law of Demeter, LoD)
一个软件实体应当尽可能少地与其他实体发生相互作用。
降低了类之间的耦合度，提高了模块的相对独立性。
由于亲合度降低，从而提高了类的可复用率和系统的扩展性。


单例：
定义：确保一个类最多只有一个实例，并提供一个全局访问点
（1）预加载只有一条语句return instance,这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。
（2）懒加载不浪费内存，但是无法保证线程的安全。


装饰者模式:
定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。
装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。如果是用继承,每当需要增加新的行为时,就要修改原程序了。


工厂模式
定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为。


外观模式
定义： 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。


责任链模式（所有的UI的消息机制都是该模式实现）
定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
。。。。。。将消息的被处理者通过连表关联起来，依次进行查阅，若是即处理，不往下传递，否则向下传递消息，直到结束。

观察者模式：（订阅模式，谁订阅了某个消息，当消息来后，会通知改对象处理）


工作经验
1. 宏
2. 谦虚，积极的心理（我师傅说过，不要老是认为晚了，多少人50岁开始崛起创造奇迹；不要说不可能，努力了进入路，就能快速的适应）
3. 自己撰写测试用例
4. 重构代码（内存泄漏：注意在函数内部new的要在内部释放，否则成员化，在析构中释放；参数列表：通过引用或指针，防止拷贝降低性能）

...QT
（1）自动适应窗口大小：
ratio = qreal(qApp->primaryScreen()->availableSize().width()) / TARGET_SCREEN_WIDTH;
qApp->primaryScreen()->availableSize()：获取显示屏幕的大小，获取其宽度，同UI窗口最大宽度的进行相除，或其比例
该比例乘以目标的宽度和长度，指定其大小

（2）信号槽
同步、异步（取决于是否处于同一线程），当特殊需求时，第五参数进行指定

（3）写代码前
a.纸上先将架构画出来，在代码实现
b.业务流程的，能在纸上将80%左右的流程画出来，再去实现，防止做无效功。

c++编译过程：
https://www.udacity.com/blog/2020/02/c-compilers-explained.html
https://oicebot.github.io/2020/03/20/c-compilers-explained.html
