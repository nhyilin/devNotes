# Table of Contents
- [Table of Contents](#table-of-contents)
- [第0章 这本书附带的源码质量不错，值得学习](#第0章-这本书附带的源码质量不错值得学习)
- [第1章 C++17的新特性](#第1章-c17的新特性)
  - [使用结构化绑定来解包绑定的返回值](#使用结构化绑定来解包绑定的返回值)
  - [将变量作用域限制在if和switch区域内](#将变量作用域限制在if和switch区域内)
  - [新的括号初始化规则](#新的括号初始化规则)
  - [构造函数自动推导模板的类型](#构造函数自动推导模板的类型)
  - [使用constexpr-if简化编译](#使用constexpr-if简化编译)
  - [只有头文件的库中启用内联变量](#只有头文件的库中启用内联变量)
  - [使用折叠表达式实现辅助函数](#使用折叠表达式实现辅助函数)
- [第2章 STL容器](#第2章-stl容器)
  - [擦除/移除std::vector元素](#擦除移除stdvector元素)
  - [以O(1)的时间复杂度删除未排序std::vector中的元素](#以o1的时间复杂度删除未排序stdvector中的元素)
  - [快速或安全的访问std::vector实例的方法](#快速或安全的访问stdvector实例的方法)
  - [保持对std::vector实例的排序](#保持对stdvector实例的排序)
  - [向std::map实例中高效并有条件的插入元素](#向stdmap实例中高效并有条件的插入元素)
  - [了解std::map::insert新的插入提示语义](#了解stdmapinsert新的插入提示语义)
  - [高效的修改std::map元素的键值](#高效的修改stdmap元素的键值)
  - [std::unordered\_map中使用自定义类型](#stdunordered_map中使用自定义类型)
  - [过滤用户的重复输入，并以字母序将重复信息打印出——std::set](#过滤用户的重复输入并以字母序将重复信息打印出stdset)
  - [实现简单的逆波兰表示法计算器——std::stack](#实现简单的逆波兰表示法计算器stdstack)
  - [实现词频计数器——std::map](#实现词频计数器stdmap)
  - [实现写作风格助手用来查找文本中很长的句子——std::multimap](#实现写作风格助手用来查找文本中很长的句子stdmultimap)
  - [实现个人待办事项列表——std::priority\_queue](#实现个人待办事项列表stdpriority_queue)
- [第3章 迭代器](#第3章-迭代器)
  - [建立可迭代区域](#建立可迭代区域)
  - [让自己的迭代器与STL的迭代器兼容](#让自己的迭代器与stl的迭代器兼容)
  - [使用迭代适配器填充通用数据结构](#使用迭代适配器填充通用数据结构)
  - [使用迭代器实现算法](#使用迭代器实现算法)
  - [使用反向迭代适配器进行迭代](#使用反向迭代适配器进行迭代)
  - [使用哨兵终止迭代](#使用哨兵终止迭代)
  - [使用检查过的迭代器自动化检查迭代器代码](#使用检查过的迭代器自动化检查迭代器代码)
  - [构建zip迭代适配器](#构建zip迭代适配器)
- [第4章 Lambda表达式](#第4章-lambda表达式)
  - [使用Lambda表达式定义函数](#使用lambda表达式定义函数)
  - [使用Lambda为std::function添加多态性](#使用lambda为stdfunction添加多态性)
  - [并置函数](#并置函数)
  - [通过逻辑连接创建复杂谓词](#通过逻辑连接创建复杂谓词)
  - [使用同一输入调用多个函数](#使用同一输入调用多个函数)
  - [使用std::accumulate和Lambda函数实现transform\_if](#使用stdaccumulate和lambda函数实现transform_if)
  - [编译时生成笛卡尔乘积](#编译时生成笛卡尔乘积)
- [第5章 STL基础算法](#第5章-stl基础算法)
  - [容器间相互复制元素](#容器间相互复制元素)
  - [容器元素排序](#容器元素排序)
  - [从容器中删除指定元素](#从容器中删除指定元素)
  - [改变容器内容](#改变容器内容)
  - [在有序和无序的vector中查找元素](#在有序和无序的vector中查找元素)
  - [将vector中的值控制在特定数值范围内——std::clamp](#将vector中的值控制在特定数值范围内stdclamp)
  - [在字符串中定位模式并选择最佳实现——std::search](#在字符串中定位模式并选择最佳实现stdsearch)
  - [对大vector进行采样](#对大vector进行采样)
  - [生成输入序列的序列](#生成输入序列的序列)
  - [实现字典合并工具](#实现字典合并工具)
- [第6章 STL算法的高级使用方式](#第6章-stl算法的高级使用方式)
  - [使用STL算法实现单词查找树类](#使用stl算法实现单词查找树类)
  - [使用树实现搜索输入建议生成器](#使用树实现搜索输入建议生成器)
  - [使用STL数值算法实现傅里叶变换](#使用stl数值算法实现傅里叶变换)
  - [计算两个vector的误差和](#计算两个vector的误差和)
  - [使用ASCII字符曼德尔布罗特集合](#使用ascii字符曼德尔布罗特集合)
  - [实现分割算法](#实现分割算法)
  - [将标准算法进行组合](#将标准算法进行组合)
  - [删除词组间连续的空格](#删除词组间连续的空格)
  - [压缩和解压缩字符串](#压缩和解压缩字符串)
- [第7章 字符串, 流和正则表达](#第7章-字符串-流和正则表达)
  - [创建、连接和转换字符串](#创建连接和转换字符串)
  - [消除字符串开始和结束处的空格](#消除字符串开始和结束处的空格)
  - [无需构造获取std::string](#无需构造获取stdstring)
  - [从用户的输入读取数值](#从用户的输入读取数值)
  - [计算文件中的单词数量](#计算文件中的单词数量)
  - [格式化输出](#格式化输出)
  - [使用输入文件初始化复杂对象](#使用输入文件初始化复杂对象)
  - [迭代器填充容器——std::istream](#迭代器填充容器stdistream)
  - [迭代器进行打印——std::ostream](#迭代器进行打印stdostream)
  - [使用特定代码段将输出重定向到文件](#使用特定代码段将输出重定向到文件)
  - [通过集成std::char\_traits创建自定义字符串类](#通过集成stdchar_traits创建自定义字符串类)
  - [使用正则表达式库标记输入](#使用正则表达式库标记输入)
  - [简单打印不同格式的数字](#简单打印不同格式的数字)
  - [从std::iostream错误中获取可读异常](#从stdiostream错误中获取可读异常)
- [第8章 工具类](#第8章-工具类)
  - [转换不同的时间单位——std::ratio](#转换不同的时间单位stdratio)
  - [转换绝对时间和相对时间——std::chrono](#转换绝对时间和相对时间stdchrono)
  - [安全的标识失败——std::optional](#安全的标识失败stdoptional)
  - [对元组使用函数](#对元组使用函数)
  - [使用元组快速构成数据结构](#使用元组快速构成数据结构)
  - [将void\*替换为更为安全的std::any](#将void替换为更为安全的stdany)
  - [存储不同的类型——std::variant](#存储不同的类型stdvariant)
  - [自动化管理资源——std::unique\_ptr](#自动化管理资源stdunique_ptr)
  - [处理共享堆内存——std::shared\_ptr](#处理共享堆内存stdshared_ptr)
  - [对共享对象使用弱指针](#对共享对象使用弱指针)
  - [使用智能指针简化处理遗留API](#使用智能指针简化处理遗留api)
  - [共享同一对象的不同成员](#共享同一对象的不同成员)
  - [选择合适的引擎生成随机数](#选择合适的引擎生成随机数)
  - [让STL以指定分布方式产生随机数](#让stl以指定分布方式产生随机数)
- [第9章 并行和并发](#第9章-并行和并发)
  - [标准算法的自动并行](#标准算法的自动并行)
  - [让程序在特定时间休眠](#让程序在特定时间休眠)
  - [启动和停止线程](#启动和停止线程)
  - [打造异常安全的共享锁——std::unique\_lock和std::shared\_lock](#打造异常安全的共享锁stdunique_lock和stdshared_lock)
  - [避免死锁——std::scoped\_lock](#避免死锁stdscoped_lock)
  - [同步并行中使用std::cout](#同步并行中使用stdcout)
  - [进行延迟初始化——std::call\_once](#进行延迟初始化stdcall_once)
  - [将执行的程序推到后台——std::async](#将执行的程序推到后台stdasync)
  - [实现生产者/消费者模型——std::condition\_variable](#实现生产者消费者模型stdcondition_variable)
  - [实现多生产者/多消费者模型——std::condition\_variable](#实现多生产者多消费者模型stdcondition_variable)
  - [并行ASCII曼德尔布罗特渲染器——std::async](#并行ascii曼德尔布罗特渲染器stdasync)
  - [实现一个小型自动化并行库——std::future](#实现一个小型自动化并行库stdfuture)
- [第10章 文件系统](#第10章-文件系统)
  - [实现标准化路径](#实现标准化路径)
  - [使用相对路径获取规范的文件路径](#使用相对路径获取规范的文件路径)
  - [列出目录下的所有文件](#列出目录下的所有文件)
  - [实现一个类似grep的文本搜索工具](#实现一个类似grep的文本搜索工具)
  - [实现一个自动文件重命名器](#实现一个自动文件重命名器)
  - [实现一个磁盘使用统计器](#实现一个磁盘使用统计器)
  - [计算文件类型的统计信息](#计算文件类型的统计信息)
  - [实现一个工具：通过符号链接减少重复文件，从而控制文件夹大小](#实现一个工具通过符号链接减少重复文件从而控制文件夹大小)

# 第0章 这本书附带的源码质量不错，值得学习

# 第1章 C++17的新特性
## 使用结构化绑定来解包绑定的返回值

## 将变量作用域限制在if和switch区域内

将变量的生命周期尽可能的限制在指定区域内，是一种非常好的代码风格。

[源码](./src/Chapter01/if_switch_initializer.cpp)里switch语句里的a到z，A到Z这种技巧值得学习

## 新的括号初始化规则

之前很少用`auto`来初始化变量，但是书中指出这种方式会造成问题。当在初始化STL容器时，如`std::vector`、`std::list`等，括号初始化就会去匹配`std::initializer_list`(初始化列表)的构造函数，从而初始化容器。书中提到了非聚合构造函数这个概念。

`{}`和`()`调用构造函数初始化的方式，不同点在于`{}`不会隐式转换，如 `int x(1.2);`和 `int x = 1.2;` 通过静默的对浮点值进行向下取整，然后将其转换为整型，从而将x的值初始化为1。相反的， `int x{1.2};` 将会遇到编译错误，初始化列表中的初始值，需要与变量声明的类型完全匹配。

## 构造函数自动推导模板的类型 
 
## 使用constexpr-if简化编译 

## 只有头文件的库中启用内联变量

## 使用折叠表达式实现辅助函数

# 第2章 STL容器
## 擦除/移除std::vector元素


## 以O(1)的时间复杂度删除未排序std::vector中的元素

## 快速或安全的访问std::vector实例的方法

## 保持对std::vector实例的排序

## 向std::map实例中高效并有条件的插入元素

## 了解std::map::insert新的插入提示语义

## 高效的修改std::map元素的键值

## std::unordered_map中使用自定义类型

## 过滤用户的重复输入，并以字母序将重复信息打印出——std::set
## 实现简单的逆波兰表示法计算器——std::stack

## 实现词频计数器——std::map

## 实现写作风格助手用来查找文本中很长的句子——std::multimap
## 实现个人待办事项列表——std::priority_queue

# 第3章 迭代器

## 建立可迭代区域

## 让自己的迭代器与STL的迭代器兼容

## 使用迭代适配器填充通用数据结构

## 使用迭代器实现算法

## 使用反向迭代适配器进行迭代

## 使用哨兵终止迭代

## 使用检查过的迭代器自动化检查迭代器代码

## 构建zip迭代适配器

# 第4章 Lambda表达式

## 使用Lambda表达式定义函数

## 使用Lambda为std::function添加多态性

## 并置函数

## 通过逻辑连接创建复杂谓词

## 使用同一输入调用多个函数

## 使用std::accumulate和Lambda函数实现transform_if

## 编译时生成笛卡尔乘积

# 第5章 STL基础算法
## 容器间相互复制元素

## 容器元素排序

## 从容器中删除指定元素

## 改变容器内容

## 在有序和无序的vector中查找元素

## 将vector中的值控制在特定数值范围内——std::clamp

## 在字符串中定位模式并选择最佳实现——std::search

## 对大vector进行采样

## 生成输入序列的序列

## 实现字典合并工具
# 第6章 STL算法的高级使用方式

## 使用STL算法实现单词查找树类

## 使用树实现搜索输入建议生成器

## 使用STL数值算法实现傅里叶变换

## 计算两个vector的误差和

## 使用ASCII字符曼德尔布罗特集合

## 实现分割算法

## 将标准算法进行组合

## 删除词组间连续的空格

## 压缩和解压缩字符串

# 第7章 字符串, 流和正则表达

## 创建、连接和转换字符串

## 消除字符串开始和结束处的空格

## 无需构造获取std::string

## 从用户的输入读取数值

## 计算文件中的单词数量

## 格式化输出

## 使用输入文件初始化复杂对象

## 迭代器填充容器——std::istream

## 迭代器进行打印——std::ostream

## 使用特定代码段将输出重定向到文件

## 通过集成std::char_traits创建自定义字符串类

## 使用正则表达式库标记输入

## 简单打印不同格式的数字

## 从std::iostream错误中获取可读异常

# 第8章 工具类

## 转换不同的时间单位——std::ratio

## 转换绝对时间和相对时间——std::chrono

## 安全的标识失败——std::optional

## 对元组使用函数

## 使用元组快速构成数据结构

## 将void*替换为更为安全的std::any

## 存储不同的类型——std::variant

## 自动化管理资源——std::unique_ptr

## 处理共享堆内存——std::shared_ptr

## 对共享对象使用弱指针

## 使用智能指针简化处理遗留API

## 共享同一对象的不同成员

## 选择合适的引擎生成随机数

## 让STL以指定分布方式产生随机数

# 第9章 并行和并发

## 标准算法的自动并行

## 让程序在特定时间休眠

## 启动和停止线程

## 打造异常安全的共享锁——std::unique_lock和std::shared_lock

## 避免死锁——std::scoped_lock

## 同步并行中使用std::cout

## 进行延迟初始化——std::call_once

## 将执行的程序推到后台——std::async

## 实现生产者/消费者模型——std::condition_variable

## 实现多生产者/多消费者模型——std::condition_variable

## 并行ASCII曼德尔布罗特渲染器——std::async

## 实现一个小型自动化并行库——std::future

# 第10章 文件系统

## 实现标准化路径

## 使用相对路径获取规范的文件路径

## 列出目录下的所有文件

## 实现一个类似grep的文本搜索工具
## 实现一个自动文件重命名器
## 实现一个磁盘使用统计器
## 计算文件类型的统计信息
## 实现一个工具：通过符号链接减少重复文件，从而控制文件夹大小




[![top] Goto Top](#table-of-contents)

[top]: up.png
[top]: https://upload.nhyilin.cn/2021-11-19-up.png